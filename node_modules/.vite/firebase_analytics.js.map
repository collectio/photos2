{
  "version": 3,
  "sources": ["../idb/lib/idb.mjs", "../@firebase/installations/src/util/constants.ts", "../@firebase/installations/src/util/errors.ts", "../@firebase/installations/src/api/common.ts", "../@firebase/installations/src/api/create-installation-request.ts", "../@firebase/installations/src/util/sleep.ts", "../@firebase/installations/src/helpers/buffer-to-base64-url-safe.ts", "../@firebase/installations/src/helpers/generate-fid.ts", "../@firebase/installations/src/util/get-key.ts", "../@firebase/installations/src/helpers/fid-changed.ts", "../@firebase/installations/src/helpers/idb-manager.ts", "../@firebase/installations/src/helpers/get-installation-entry.ts", "../@firebase/installations/src/api/generate-auth-token-request.ts", "../@firebase/installations/src/helpers/refresh-auth-token.ts", "../@firebase/installations/src/functions/get-id.ts", "../@firebase/installations/src/functions/get-token.ts", "../@firebase/installations/src/api/delete-installation-request.ts", "../@firebase/installations/src/functions/delete-installation.ts", "../@firebase/installations/src/functions/on-id-change.ts", "../@firebase/installations/src/helpers/extract-app-config.ts", "../@firebase/installations/src/index.ts", "../@firebase/analytics/src/constants.ts", "../@firebase/analytics/src/functions.ts", "../@firebase/analytics/src/logger.ts", "../@firebase/analytics/src/helpers.ts", "../@firebase/analytics/src/errors.ts", "../@firebase/analytics/src/get-config.ts", "../@firebase/analytics/src/initialize-ids.ts", "../@firebase/analytics/src/factory.ts", "../@firebase/analytics/index.ts"],
  "sourcesContent": ["function toArray(arr) {\n  return Array.prototype.slice.call(arr);\n}\n\nfunction promisifyRequest(request) {\n  return new Promise(function(resolve, reject) {\n    request.onsuccess = function() {\n      resolve(request.result);\n    };\n\n    request.onerror = function() {\n      reject(request.error);\n    };\n  });\n}\n\nfunction promisifyRequestCall(obj, method, args) {\n  var request;\n  var p = new Promise(function(resolve, reject) {\n    request = obj[method].apply(obj, args);\n    promisifyRequest(request).then(resolve, reject);\n  });\n\n  p.request = request;\n  return p;\n}\n\nfunction promisifyCursorRequestCall(obj, method, args) {\n  var p = promisifyRequestCall(obj, method, args);\n  return p.then(function(value) {\n    if (!value) return;\n    return new Cursor(value, p.request);\n  });\n}\n\nfunction proxyProperties(ProxyClass, targetProp, properties) {\n  properties.forEach(function(prop) {\n    Object.defineProperty(ProxyClass.prototype, prop, {\n      get: function() {\n        return this[targetProp][prop];\n      },\n      set: function(val) {\n        this[targetProp][prop] = val;\n      }\n    });\n  });\n}\n\nfunction proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n  properties.forEach(function(prop) {\n    if (!(prop in Constructor.prototype)) return;\n    ProxyClass.prototype[prop] = function() {\n      return promisifyRequestCall(this[targetProp], prop, arguments);\n    };\n  });\n}\n\nfunction proxyMethods(ProxyClass, targetProp, Constructor, properties) {\n  properties.forEach(function(prop) {\n    if (!(prop in Constructor.prototype)) return;\n    ProxyClass.prototype[prop] = function() {\n      return this[targetProp][prop].apply(this[targetProp], arguments);\n    };\n  });\n}\n\nfunction proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n  properties.forEach(function(prop) {\n    if (!(prop in Constructor.prototype)) return;\n    ProxyClass.prototype[prop] = function() {\n      return promisifyCursorRequestCall(this[targetProp], prop, arguments);\n    };\n  });\n}\n\nfunction Index(index) {\n  this._index = index;\n}\n\nproxyProperties(Index, '_index', [\n  'name',\n  'keyPath',\n  'multiEntry',\n  'unique'\n]);\n\nproxyRequestMethods(Index, '_index', IDBIndex, [\n  'get',\n  'getKey',\n  'getAll',\n  'getAllKeys',\n  'count'\n]);\n\nproxyCursorRequestMethods(Index, '_index', IDBIndex, [\n  'openCursor',\n  'openKeyCursor'\n]);\n\nfunction Cursor(cursor, request) {\n  this._cursor = cursor;\n  this._request = request;\n}\n\nproxyProperties(Cursor, '_cursor', [\n  'direction',\n  'key',\n  'primaryKey',\n  'value'\n]);\n\nproxyRequestMethods(Cursor, '_cursor', IDBCursor, [\n  'update',\n  'delete'\n]);\n\n// proxy 'next' methods\n['advance', 'continue', 'continuePrimaryKey'].forEach(function(methodName) {\n  if (!(methodName in IDBCursor.prototype)) return;\n  Cursor.prototype[methodName] = function() {\n    var cursor = this;\n    var args = arguments;\n    return Promise.resolve().then(function() {\n      cursor._cursor[methodName].apply(cursor._cursor, args);\n      return promisifyRequest(cursor._request).then(function(value) {\n        if (!value) return;\n        return new Cursor(value, cursor._request);\n      });\n    });\n  };\n});\n\nfunction ObjectStore(store) {\n  this._store = store;\n}\n\nObjectStore.prototype.createIndex = function() {\n  return new Index(this._store.createIndex.apply(this._store, arguments));\n};\n\nObjectStore.prototype.index = function() {\n  return new Index(this._store.index.apply(this._store, arguments));\n};\n\nproxyProperties(ObjectStore, '_store', [\n  'name',\n  'keyPath',\n  'indexNames',\n  'autoIncrement'\n]);\n\nproxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n  'put',\n  'add',\n  'delete',\n  'clear',\n  'get',\n  'getAll',\n  'getKey',\n  'getAllKeys',\n  'count'\n]);\n\nproxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n  'openCursor',\n  'openKeyCursor'\n]);\n\nproxyMethods(ObjectStore, '_store', IDBObjectStore, [\n  'deleteIndex'\n]);\n\nfunction Transaction(idbTransaction) {\n  this._tx = idbTransaction;\n  this.complete = new Promise(function(resolve, reject) {\n    idbTransaction.oncomplete = function() {\n      resolve();\n    };\n    idbTransaction.onerror = function() {\n      reject(idbTransaction.error);\n    };\n    idbTransaction.onabort = function() {\n      reject(idbTransaction.error);\n    };\n  });\n}\n\nTransaction.prototype.objectStore = function() {\n  return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));\n};\n\nproxyProperties(Transaction, '_tx', [\n  'objectStoreNames',\n  'mode'\n]);\n\nproxyMethods(Transaction, '_tx', IDBTransaction, [\n  'abort'\n]);\n\nfunction UpgradeDB(db, oldVersion, transaction) {\n  this._db = db;\n  this.oldVersion = oldVersion;\n  this.transaction = new Transaction(transaction);\n}\n\nUpgradeDB.prototype.createObjectStore = function() {\n  return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));\n};\n\nproxyProperties(UpgradeDB, '_db', [\n  'name',\n  'version',\n  'objectStoreNames'\n]);\n\nproxyMethods(UpgradeDB, '_db', IDBDatabase, [\n  'deleteObjectStore',\n  'close'\n]);\n\nfunction DB(db) {\n  this._db = db;\n}\n\nDB.prototype.transaction = function() {\n  return new Transaction(this._db.transaction.apply(this._db, arguments));\n};\n\nproxyProperties(DB, '_db', [\n  'name',\n  'version',\n  'objectStoreNames'\n]);\n\nproxyMethods(DB, '_db', IDBDatabase, [\n  'close'\n]);\n\n// Add cursor iterators\n// TODO: remove this once browsers do the right thing with promises\n['openCursor', 'openKeyCursor'].forEach(function(funcName) {\n  [ObjectStore, Index].forEach(function(Constructor) {\n    // Don't create iterateKeyCursor if openKeyCursor doesn't exist.\n    if (!(funcName in Constructor.prototype)) return;\n\n    Constructor.prototype[funcName.replace('open', 'iterate')] = function() {\n      var args = toArray(arguments);\n      var callback = args[args.length - 1];\n      var nativeObject = this._store || this._index;\n      var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));\n      request.onsuccess = function() {\n        callback(request.result);\n      };\n    };\n  });\n});\n\n// polyfill getAll\n[Index, ObjectStore].forEach(function(Constructor) {\n  if (Constructor.prototype.getAll) return;\n  Constructor.prototype.getAll = function(query, count) {\n    var instance = this;\n    var items = [];\n\n    return new Promise(function(resolve) {\n      instance.iterateCursor(query, function(cursor) {\n        if (!cursor) {\n          resolve(items);\n          return;\n        }\n        items.push(cursor.value);\n\n        if (count !== undefined && items.length == count) {\n          resolve(items);\n          return;\n        }\n        cursor.continue();\n      });\n    });\n  };\n});\n\nexport function openDb(name, version, upgradeCallback) {\n  var p = promisifyRequestCall(indexedDB, 'open', [name, version]);\n  var request = p.request;\n\n  if (request) {\n    request.onupgradeneeded = function(event) {\n      if (upgradeCallback) {\n        upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));\n      }\n    };\n  }\n\n  return p.then(function(db) {\n    return new DB(db);\n  });\n}\n\nexport function deleteDb(name) {\n  return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { version } from '../../package.json';\n\nexport const PENDING_TIMEOUT_MS = 10000;\n\nexport const PACKAGE_VERSION = `w:${version}`;\nexport const INTERNAL_AUTH_VERSION = 'FIS_v2';\n\nexport const INSTALLATIONS_API_URL =\n  'https://firebaseinstallations.googleapis.com/v1';\n\nexport const TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour\n\nexport const SERVICE = 'installations';\nexport const SERVICE_NAME = 'Installations';\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorFactory, FirebaseError } from '@firebase/util';\nimport { SERVICE, SERVICE_NAME } from './constants';\n\nexport const enum ErrorCode {\n  MISSING_APP_CONFIG_VALUES = 'missing-app-config-values',\n  NOT_REGISTERED = 'not-registered',\n  INSTALLATION_NOT_FOUND = 'installation-not-found',\n  REQUEST_FAILED = 'request-failed',\n  APP_OFFLINE = 'app-offline',\n  DELETE_PENDING_REGISTRATION = 'delete-pending-registration'\n}\n\nconst ERROR_DESCRIPTION_MAP: { readonly [key in ErrorCode]: string } = {\n  [ErrorCode.MISSING_APP_CONFIG_VALUES]:\n    'Missing App configuration value: \"{$valueName}\"',\n  [ErrorCode.NOT_REGISTERED]: 'Firebase Installation is not registered.',\n  [ErrorCode.INSTALLATION_NOT_FOUND]: 'Firebase Installation not found.',\n  [ErrorCode.REQUEST_FAILED]:\n    '{$requestName} request failed with error \"{$serverCode} {$serverStatus}: {$serverMessage}\"',\n  [ErrorCode.APP_OFFLINE]: 'Could not process request. Application offline.',\n  [ErrorCode.DELETE_PENDING_REGISTRATION]:\n    \"Can't delete installation while there is a pending registration request.\"\n};\n\ninterface ErrorParams {\n  [ErrorCode.MISSING_APP_CONFIG_VALUES]: {\n    valueName: string;\n  };\n  [ErrorCode.REQUEST_FAILED]: {\n    requestName: string;\n    [index: string]: string | number; // to make Typescript 3.8 happy\n  } & ServerErrorData;\n}\n\nexport const ERROR_FACTORY = new ErrorFactory<ErrorCode, ErrorParams>(\n  SERVICE,\n  SERVICE_NAME,\n  ERROR_DESCRIPTION_MAP\n);\n\nexport interface ServerErrorData {\n  serverCode: number;\n  serverMessage: string;\n  serverStatus: string;\n}\n\nexport type ServerError = FirebaseError & { customData: ServerErrorData };\n\n/** Returns true if error is a FirebaseError that is based on an error from the server. */\nexport function isServerError(error: unknown): error is ServerError {\n  return (\n    error instanceof FirebaseError &&\n    error.code.includes(ErrorCode.REQUEST_FAILED)\n  );\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseError } from '@firebase/util';\nimport { GenerateAuthTokenResponse } from '../interfaces/api-response';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  CompletedAuthToken,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport {\n  INSTALLATIONS_API_URL,\n  INTERNAL_AUTH_VERSION\n} from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport function getInstallationsEndpoint({ projectId }: AppConfig): string {\n  return `${INSTALLATIONS_API_URL}/projects/${projectId}/installations`;\n}\n\nexport function extractAuthTokenInfoFromResponse(\n  response: GenerateAuthTokenResponse\n): CompletedAuthToken {\n  return {\n    token: response.token,\n    requestStatus: RequestStatus.COMPLETED,\n    expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),\n    creationTime: Date.now()\n  };\n}\n\nexport async function getErrorFromResponse(\n  requestName: string,\n  response: Response\n): Promise<FirebaseError> {\n  const responseJson: ErrorResponse = await response.json();\n  const errorData = responseJson.error;\n  return ERROR_FACTORY.create(ErrorCode.REQUEST_FAILED, {\n    requestName,\n    serverCode: errorData.code,\n    serverMessage: errorData.message,\n    serverStatus: errorData.status\n  });\n}\n\nexport function getHeaders({ apiKey }: AppConfig): Headers {\n  return new Headers({\n    'Content-Type': 'application/json',\n    Accept: 'application/json',\n    'x-goog-api-key': apiKey\n  });\n}\n\nexport function getHeadersWithAuth(\n  appConfig: AppConfig,\n  { refreshToken }: RegisteredInstallationEntry\n): Headers {\n  const headers = getHeaders(appConfig);\n  headers.append('Authorization', getAuthorizationHeader(refreshToken));\n  return headers;\n}\n\nexport interface ErrorResponse {\n  error: {\n    code: number;\n    message: string;\n    status: string;\n  };\n}\n\n/**\n * Calls the passed in fetch wrapper and returns the response.\n * If the returned response has a status of 5xx, re-runs the function once and\n * returns the response.\n */\nexport async function retryIfServerError(\n  fn: () => Promise<Response>\n): Promise<Response> {\n  const result = await fn();\n\n  if (result.status >= 500 && result.status < 600) {\n    // Internal Server Error. Retry request.\n    return fn();\n  }\n\n  return result;\n}\n\nfunction getExpiresInFromResponseExpiresIn(responseExpiresIn: string): number {\n  // This works because the server will never respond with fractions of a second.\n  return Number(responseExpiresIn.replace('s', '000'));\n}\n\nfunction getAuthorizationHeader(refreshToken: string): string {\n  return `${INTERNAL_AUTH_VERSION} ${refreshToken}`;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CreateInstallationResponse } from '../interfaces/api-response';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  InProgressInstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { INTERNAL_AUTH_VERSION, PACKAGE_VERSION } from '../util/constants';\nimport {\n  extractAuthTokenInfoFromResponse,\n  getErrorFromResponse,\n  getHeaders,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\n\nexport async function createInstallationRequest(\n  appConfig: AppConfig,\n  { fid }: InProgressInstallationEntry\n): Promise<RegisteredInstallationEntry> {\n  const endpoint = getInstallationsEndpoint(appConfig);\n\n  const headers = getHeaders(appConfig);\n  const body = {\n    fid,\n    authVersion: INTERNAL_AUTH_VERSION,\n    appId: appConfig.appId,\n    sdkVersion: PACKAGE_VERSION\n  };\n\n  const request: RequestInit = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body)\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (response.ok) {\n    const responseValue: CreateInstallationResponse = await response.json();\n    const registeredInstallationEntry: RegisteredInstallationEntry = {\n      fid: responseValue.fid || fid,\n      registrationStatus: RequestStatus.COMPLETED,\n      refreshToken: responseValue.refreshToken,\n      authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)\n    };\n    return registeredInstallationEntry;\n  } else {\n    throw await getErrorFromResponse('Create Installation', response);\n  }\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** Returns a promise that resolves after given time passes. */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise<void>(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function bufferToBase64UrlSafe(array: Uint8Array): string {\n  const b64 = btoa(String.fromCharCode(...array));\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { bufferToBase64UrlSafe } from './buffer-to-base64-url-safe';\n\nexport const VALID_FID_PATTERN = /^[cdef][\\w-]{21}$/;\nexport const INVALID_FID = '';\n\n/**\n * Generates a new FID using random values from Web Crypto API.\n * Returns an empty string if FID generation fails for any reason.\n */\nexport function generateFid(): string {\n  try {\n    // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5\n    // bytes. our implementation generates a 17 byte array instead.\n    const fidByteArray = new Uint8Array(17);\n    const crypto =\n      self.crypto || ((self as unknown) as { msCrypto: Crypto }).msCrypto;\n    crypto.getRandomValues(fidByteArray);\n\n    // Replace the first 4 random bits with the constant FID header of 0b0111.\n    fidByteArray[0] = 0b01110000 + (fidByteArray[0] % 0b00010000);\n\n    const fid = encode(fidByteArray);\n\n    return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;\n  } catch {\n    // FID generation errored\n    return INVALID_FID;\n  }\n}\n\n/** Converts a FID Uint8Array to a base64 string representation. */\nfunction encode(fidByteArray: Uint8Array): string {\n  const b64String = bufferToBase64UrlSafe(fidByteArray);\n\n  // Remove the 23rd character that was added because of the extra 4 bits at the\n  // end of our 17 byte array, and the '=' padding.\n  return b64String.substr(0, 22);\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppConfig } from '../interfaces/app-config';\n\n/** Returns a string key that can be used to identify the app. */\nexport function getKey(appConfig: AppConfig): string {\n  return `${appConfig.appName}!${appConfig.appId}`;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getKey } from '../util/get-key';\nimport { AppConfig } from '../interfaces/app-config';\nimport { IdChangeCallbackFn } from '../functions';\n\nconst fidChangeCallbacks: Map<string, Set<IdChangeCallbackFn>> = new Map();\n\n/**\n * Calls the onIdChange callbacks with the new FID value, and broadcasts the\n * change to other tabs.\n */\nexport function fidChanged(appConfig: AppConfig, fid: string): void {\n  const key = getKey(appConfig);\n\n  callFidChangeCallbacks(key, fid);\n  broadcastFidChange(key, fid);\n}\n\nexport function addCallback(\n  appConfig: AppConfig,\n  callback: IdChangeCallbackFn\n): void {\n  // Open the broadcast channel if it's not already open,\n  // to be able to listen to change events from other tabs.\n  getBroadcastChannel();\n\n  const key = getKey(appConfig);\n\n  let callbackSet = fidChangeCallbacks.get(key);\n  if (!callbackSet) {\n    callbackSet = new Set();\n    fidChangeCallbacks.set(key, callbackSet);\n  }\n  callbackSet.add(callback);\n}\n\nexport function removeCallback(\n  appConfig: AppConfig,\n  callback: IdChangeCallbackFn\n): void {\n  const key = getKey(appConfig);\n\n  const callbackSet = fidChangeCallbacks.get(key);\n\n  if (!callbackSet) {\n    return;\n  }\n\n  callbackSet.delete(callback);\n  if (callbackSet.size === 0) {\n    fidChangeCallbacks.delete(key);\n  }\n\n  // Close broadcast channel if there are no more callbacks.\n  closeBroadcastChannel();\n}\n\nfunction callFidChangeCallbacks(key: string, fid: string): void {\n  const callbacks = fidChangeCallbacks.get(key);\n  if (!callbacks) {\n    return;\n  }\n\n  for (const callback of callbacks) {\n    callback(fid);\n  }\n}\n\nfunction broadcastFidChange(key: string, fid: string): void {\n  const channel = getBroadcastChannel();\n  if (channel) {\n    channel.postMessage({ key, fid });\n  }\n  closeBroadcastChannel();\n}\n\nlet broadcastChannel: BroadcastChannel | null = null;\n/** Opens and returns a BroadcastChannel if it is supported by the browser. */\nfunction getBroadcastChannel(): BroadcastChannel | null {\n  if (!broadcastChannel && 'BroadcastChannel' in self) {\n    broadcastChannel = new BroadcastChannel('[Firebase] FID Change');\n    broadcastChannel.onmessage = e => {\n      callFidChangeCallbacks(e.data.key, e.data.fid);\n    };\n  }\n  return broadcastChannel;\n}\n\nfunction closeBroadcastChannel(): void {\n  if (fidChangeCallbacks.size === 0 && broadcastChannel) {\n    broadcastChannel.close();\n    broadcastChannel = null;\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DB, openDb } from 'idb';\nimport { AppConfig } from '../interfaces/app-config';\nimport { InstallationEntry } from '../interfaces/installation-entry';\nimport { getKey } from '../util/get-key';\nimport { fidChanged } from './fid-changed';\n\nconst DATABASE_NAME = 'firebase-installations-database';\nconst DATABASE_VERSION = 1;\nconst OBJECT_STORE_NAME = 'firebase-installations-store';\n\nlet dbPromise: Promise<DB> | null = null;\nfunction getDbPromise(): Promise<DB> {\n  if (!dbPromise) {\n    dbPromise = openDb(DATABASE_NAME, DATABASE_VERSION, upgradeDB => {\n      // We don't use 'break' in this switch statement, the fall-through\n      // behavior is what we want, because if there are multiple versions between\n      // the old version and the current version, we want ALL the migrations\n      // that correspond to those versions to run, not only the last one.\n      // eslint-disable-next-line default-case\n      switch (upgradeDB.oldVersion) {\n        case 0:\n          upgradeDB.createObjectStore(OBJECT_STORE_NAME);\n      }\n    });\n  }\n  return dbPromise;\n}\n\n/** Gets record(s) from the objectStore that match the given key. */\nexport async function get(\n  appConfig: AppConfig\n): Promise<InstallationEntry | undefined> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  return db\n    .transaction(OBJECT_STORE_NAME)\n    .objectStore(OBJECT_STORE_NAME)\n    .get(key);\n}\n\n/** Assigns or overwrites the record for the given key with the given value. */\nexport async function set<ValueType extends InstallationEntry>(\n  appConfig: AppConfig,\n  value: ValueType\n): Promise<ValueType> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  const objectStore = tx.objectStore(OBJECT_STORE_NAME);\n  const oldValue = await objectStore.get(key);\n  await objectStore.put(value, key);\n  await tx.complete;\n\n  if (!oldValue || oldValue.fid !== value.fid) {\n    fidChanged(appConfig, value.fid);\n  }\n\n  return value;\n}\n\n/** Removes record(s) from the objectStore that match the given key. */\nexport async function remove(appConfig: AppConfig): Promise<void> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  await tx.objectStore(OBJECT_STORE_NAME).delete(key);\n  await tx.complete;\n}\n\n/**\n * Atomically updates a record with the result of updateFn, which gets\n * called with the current value. If newValue is undefined, the record is\n * deleted instead.\n * @return Updated value\n */\nexport async function update<ValueType extends InstallationEntry | undefined>(\n  appConfig: AppConfig,\n  updateFn: (previousValue: InstallationEntry | undefined) => ValueType\n): Promise<ValueType> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  const store = tx.objectStore(OBJECT_STORE_NAME);\n  const oldValue: InstallationEntry | undefined = await store.get(key);\n  const newValue = updateFn(oldValue);\n\n  if (newValue === undefined) {\n    await store.delete(key);\n  } else {\n    await store.put(newValue, key);\n  }\n  await tx.complete;\n\n  if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {\n    fidChanged(appConfig, newValue.fid);\n  }\n\n  return newValue;\n}\n\nexport async function clear(): Promise<void> {\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  await tx.objectStore(OBJECT_STORE_NAME).clear();\n  await tx.complete;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createInstallationRequest } from '../api/create-installation-request';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  InProgressInstallationEntry,\n  InstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { PENDING_TIMEOUT_MS } from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode, isServerError } from '../util/errors';\nimport { sleep } from '../util/sleep';\nimport { generateFid, INVALID_FID } from './generate-fid';\nimport { remove, set, update } from './idb-manager';\n\nexport interface InstallationEntryWithRegistrationPromise {\n  installationEntry: InstallationEntry;\n  /** Exist iff the installationEntry is not registered. */\n  registrationPromise?: Promise<RegisteredInstallationEntry>;\n}\n\n/**\n * Updates and returns the InstallationEntry from the database.\n * Also triggers a registration request if it is necessary and possible.\n */\nexport async function getInstallationEntry(\n  appConfig: AppConfig\n): Promise<InstallationEntryWithRegistrationPromise> {\n  let registrationPromise: Promise<RegisteredInstallationEntry> | undefined;\n\n  const installationEntry = await update(appConfig, oldEntry => {\n    const installationEntry = updateOrCreateInstallationEntry(oldEntry);\n    const entryWithPromise = triggerRegistrationIfNecessary(\n      appConfig,\n      installationEntry\n    );\n    registrationPromise = entryWithPromise.registrationPromise;\n    return entryWithPromise.installationEntry;\n  });\n\n  if (installationEntry.fid === INVALID_FID) {\n    // FID generation failed. Waiting for the FID from the server.\n    return { installationEntry: await registrationPromise! };\n  }\n\n  return {\n    installationEntry,\n    registrationPromise\n  };\n}\n\n/**\n * Creates a new Installation Entry if one does not exist.\n * Also clears timed out pending requests.\n */\nfunction updateOrCreateInstallationEntry(\n  oldEntry: InstallationEntry | undefined\n): InstallationEntry {\n  const entry: InstallationEntry = oldEntry || {\n    fid: generateFid(),\n    registrationStatus: RequestStatus.NOT_STARTED\n  };\n\n  return clearTimedOutRequest(entry);\n}\n\n/**\n * If the Firebase Installation is not registered yet, this will trigger the\n * registration and return an InProgressInstallationEntry.\n *\n * If registrationPromise does not exist, the installationEntry is guaranteed\n * to be registered.\n */\nfunction triggerRegistrationIfNecessary(\n  appConfig: AppConfig,\n  installationEntry: InstallationEntry\n): InstallationEntryWithRegistrationPromise {\n  if (installationEntry.registrationStatus === RequestStatus.NOT_STARTED) {\n    if (!navigator.onLine) {\n      // Registration required but app is offline.\n      const registrationPromiseWithError = Promise.reject(\n        ERROR_FACTORY.create(ErrorCode.APP_OFFLINE)\n      );\n      return {\n        installationEntry,\n        registrationPromise: registrationPromiseWithError\n      };\n    }\n\n    // Try registering. Change status to IN_PROGRESS.\n    const inProgressEntry: InProgressInstallationEntry = {\n      fid: installationEntry.fid,\n      registrationStatus: RequestStatus.IN_PROGRESS,\n      registrationTime: Date.now()\n    };\n    const registrationPromise = registerInstallation(\n      appConfig,\n      inProgressEntry\n    );\n    return { installationEntry: inProgressEntry, registrationPromise };\n  } else if (\n    installationEntry.registrationStatus === RequestStatus.IN_PROGRESS\n  ) {\n    return {\n      installationEntry,\n      registrationPromise: waitUntilFidRegistration(appConfig)\n    };\n  } else {\n    return { installationEntry };\n  }\n}\n\n/** This will be executed only once for each new Firebase Installation. */\nasync function registerInstallation(\n  appConfig: AppConfig,\n  installationEntry: InProgressInstallationEntry\n): Promise<RegisteredInstallationEntry> {\n  try {\n    const registeredInstallationEntry = await createInstallationRequest(\n      appConfig,\n      installationEntry\n    );\n    return set(appConfig, registeredInstallationEntry);\n  } catch (e) {\n    if (isServerError(e) && e.customData.serverCode === 409) {\n      // Server returned a \"FID can not be used\" error.\n      // Generate a new ID next time.\n      await remove(appConfig);\n    } else {\n      // Registration failed. Set FID as not registered.\n      await set(appConfig, {\n        fid: installationEntry.fid,\n        registrationStatus: RequestStatus.NOT_STARTED\n      });\n    }\n    throw e;\n  }\n}\n\n/** Call if FID registration is pending in another request. */\nasync function waitUntilFidRegistration(\n  appConfig: AppConfig\n): Promise<RegisteredInstallationEntry> {\n  // Unfortunately, there is no way of reliably observing when a value in\n  // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n  // so we need to poll.\n\n  let entry: InstallationEntry = await updateInstallationRequest(appConfig);\n  while (entry.registrationStatus === RequestStatus.IN_PROGRESS) {\n    // createInstallation request still in progress.\n    await sleep(100);\n\n    entry = await updateInstallationRequest(appConfig);\n  }\n\n  if (entry.registrationStatus === RequestStatus.NOT_STARTED) {\n    // The request timed out or failed in a different call. Try again.\n    const {\n      installationEntry,\n      registrationPromise\n    } = await getInstallationEntry(appConfig);\n\n    if (registrationPromise) {\n      return registrationPromise;\n    } else {\n      // if there is no registrationPromise, entry is registered.\n      return installationEntry as RegisteredInstallationEntry;\n    }\n  }\n\n  return entry;\n}\n\n/**\n * Called only if there is a CreateInstallation request in progress.\n *\n * Updates the InstallationEntry in the DB based on the status of the\n * CreateInstallation request.\n *\n * Returns the updated InstallationEntry.\n */\nfunction updateInstallationRequest(\n  appConfig: AppConfig\n): Promise<InstallationEntry> {\n  return update(appConfig, oldEntry => {\n    if (!oldEntry) {\n      throw ERROR_FACTORY.create(ErrorCode.INSTALLATION_NOT_FOUND);\n    }\n    return clearTimedOutRequest(oldEntry);\n  });\n}\n\nfunction clearTimedOutRequest(entry: InstallationEntry): InstallationEntry {\n  if (hasInstallationRequestTimedOut(entry)) {\n    return {\n      fid: entry.fid,\n      registrationStatus: RequestStatus.NOT_STARTED\n    };\n  }\n\n  return entry;\n}\n\nfunction hasInstallationRequestTimedOut(\n  installationEntry: InstallationEntry\n): boolean {\n  return (\n    installationEntry.registrationStatus === RequestStatus.IN_PROGRESS &&\n    installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now()\n  );\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GenerateAuthTokenResponse } from '../interfaces/api-response';\nimport { AppConfig } from '../interfaces/app-config';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\nimport {\n  CompletedAuthToken,\n  RegisteredInstallationEntry\n} from '../interfaces/installation-entry';\nimport { PACKAGE_VERSION } from '../util/constants';\nimport {\n  extractAuthTokenInfoFromResponse,\n  getErrorFromResponse,\n  getHeadersWithAuth,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\n\nexport async function generateAuthTokenRequest(\n  { appConfig, platformLoggerProvider }: FirebaseDependencies,\n  installationEntry: RegisteredInstallationEntry\n): Promise<CompletedAuthToken> {\n  const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);\n\n  const headers = getHeadersWithAuth(appConfig, installationEntry);\n\n  // If platform logger exists, add the platform info string to the header.\n  const platformLogger = platformLoggerProvider.getImmediate({\n    optional: true\n  });\n  if (platformLogger) {\n    headers.append('x-firebase-client', platformLogger.getPlatformInfoString());\n  }\n\n  const body = {\n    installation: {\n      sdkVersion: PACKAGE_VERSION\n    }\n  };\n\n  const request: RequestInit = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body)\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (response.ok) {\n    const responseValue: GenerateAuthTokenResponse = await response.json();\n    const completedAuthToken: CompletedAuthToken = extractAuthTokenInfoFromResponse(\n      responseValue\n    );\n    return completedAuthToken;\n  } else {\n    throw await getErrorFromResponse('Generate Auth Token', response);\n  }\n}\n\nfunction getGenerateAuthTokenEndpoint(\n  appConfig: AppConfig,\n  { fid }: RegisteredInstallationEntry\n): string {\n  return `${getInstallationsEndpoint(appConfig)}/${fid}/authTokens:generate`;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { generateAuthTokenRequest } from '../api/generate-auth-token-request';\nimport { AppConfig } from '../interfaces/app-config';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\nimport {\n  AuthToken,\n  CompletedAuthToken,\n  InProgressAuthToken,\n  InstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { PENDING_TIMEOUT_MS, TOKEN_EXPIRATION_BUFFER } from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode, isServerError } from '../util/errors';\nimport { sleep } from '../util/sleep';\nimport { remove, set, update } from './idb-manager';\n\n/**\n * Returns a valid authentication token for the installation. Generates a new\n * token if one doesn't exist, is expired or about to expire.\n *\n * Should only be called if the Firebase Installation is registered.\n */\nexport async function refreshAuthToken(\n  dependencies: FirebaseDependencies,\n  forceRefresh = false\n): Promise<CompletedAuthToken> {\n  let tokenPromise: Promise<CompletedAuthToken> | undefined;\n  const entry = await update(dependencies.appConfig, oldEntry => {\n    if (!isEntryRegistered(oldEntry)) {\n      throw ERROR_FACTORY.create(ErrorCode.NOT_REGISTERED);\n    }\n\n    const oldAuthToken = oldEntry.authToken;\n    if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {\n      // There is a valid token in the DB.\n      return oldEntry;\n    } else if (oldAuthToken.requestStatus === RequestStatus.IN_PROGRESS) {\n      // There already is a token request in progress.\n      tokenPromise = waitUntilAuthTokenRequest(dependencies, forceRefresh);\n      return oldEntry;\n    } else {\n      // No token or token expired.\n      if (!navigator.onLine) {\n        throw ERROR_FACTORY.create(ErrorCode.APP_OFFLINE);\n      }\n\n      const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);\n      tokenPromise = fetchAuthTokenFromServer(dependencies, inProgressEntry);\n      return inProgressEntry;\n    }\n  });\n\n  const authToken = tokenPromise\n    ? await tokenPromise\n    : (entry.authToken as CompletedAuthToken);\n  return authToken;\n}\n\n/**\n * Call only if FID is registered and Auth Token request is in progress.\n *\n * Waits until the current pending request finishes. If the request times out,\n * tries once in this thread as well.\n */\nasync function waitUntilAuthTokenRequest(\n  dependencies: FirebaseDependencies,\n  forceRefresh: boolean\n): Promise<CompletedAuthToken> {\n  // Unfortunately, there is no way of reliably observing when a value in\n  // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n  // so we need to poll.\n\n  let entry = await updateAuthTokenRequest(dependencies.appConfig);\n  while (entry.authToken.requestStatus === RequestStatus.IN_PROGRESS) {\n    // generateAuthToken still in progress.\n    await sleep(100);\n\n    entry = await updateAuthTokenRequest(dependencies.appConfig);\n  }\n\n  const authToken = entry.authToken;\n  if (authToken.requestStatus === RequestStatus.NOT_STARTED) {\n    // The request timed out or failed in a different call. Try again.\n    return refreshAuthToken(dependencies, forceRefresh);\n  } else {\n    return authToken;\n  }\n}\n\n/**\n * Called only if there is a GenerateAuthToken request in progress.\n *\n * Updates the InstallationEntry in the DB based on the status of the\n * GenerateAuthToken request.\n *\n * Returns the updated InstallationEntry.\n */\nfunction updateAuthTokenRequest(\n  appConfig: AppConfig\n): Promise<RegisteredInstallationEntry> {\n  return update(appConfig, oldEntry => {\n    if (!isEntryRegistered(oldEntry)) {\n      throw ERROR_FACTORY.create(ErrorCode.NOT_REGISTERED);\n    }\n\n    const oldAuthToken = oldEntry.authToken;\n    if (hasAuthTokenRequestTimedOut(oldAuthToken)) {\n      return {\n        ...oldEntry,\n        authToken: { requestStatus: RequestStatus.NOT_STARTED }\n      };\n    }\n\n    return oldEntry;\n  });\n}\n\nasync function fetchAuthTokenFromServer(\n  dependencies: FirebaseDependencies,\n  installationEntry: RegisteredInstallationEntry\n): Promise<CompletedAuthToken> {\n  try {\n    const authToken = await generateAuthTokenRequest(\n      dependencies,\n      installationEntry\n    );\n    const updatedInstallationEntry: RegisteredInstallationEntry = {\n      ...installationEntry,\n      authToken\n    };\n    await set(dependencies.appConfig, updatedInstallationEntry);\n    return authToken;\n  } catch (e) {\n    if (\n      isServerError(e) &&\n      (e.customData.serverCode === 401 || e.customData.serverCode === 404)\n    ) {\n      // Server returned a \"FID not found\" or a \"Invalid authentication\" error.\n      // Generate a new ID next time.\n      await remove(dependencies.appConfig);\n    } else {\n      const updatedInstallationEntry: RegisteredInstallationEntry = {\n        ...installationEntry,\n        authToken: { requestStatus: RequestStatus.NOT_STARTED }\n      };\n      await set(dependencies.appConfig, updatedInstallationEntry);\n    }\n    throw e;\n  }\n}\n\nfunction isEntryRegistered(\n  installationEntry: InstallationEntry | undefined\n): installationEntry is RegisteredInstallationEntry {\n  return (\n    installationEntry !== undefined &&\n    installationEntry.registrationStatus === RequestStatus.COMPLETED\n  );\n}\n\nfunction isAuthTokenValid(authToken: AuthToken): boolean {\n  return (\n    authToken.requestStatus === RequestStatus.COMPLETED &&\n    !isAuthTokenExpired(authToken)\n  );\n}\n\nfunction isAuthTokenExpired(authToken: CompletedAuthToken): boolean {\n  const now = Date.now();\n  return (\n    now < authToken.creationTime ||\n    authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER\n  );\n}\n\n/** Returns an updated InstallationEntry with an InProgressAuthToken. */\nfunction makeAuthTokenRequestInProgressEntry(\n  oldEntry: RegisteredInstallationEntry\n): RegisteredInstallationEntry {\n  const inProgressAuthToken: InProgressAuthToken = {\n    requestStatus: RequestStatus.IN_PROGRESS,\n    requestTime: Date.now()\n  };\n  return {\n    ...oldEntry,\n    authToken: inProgressAuthToken\n  };\n}\n\nfunction hasAuthTokenRequestTimedOut(authToken: AuthToken): boolean {\n  return (\n    authToken.requestStatus === RequestStatus.IN_PROGRESS &&\n    authToken.requestTime + PENDING_TIMEOUT_MS < Date.now()\n  );\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getInstallationEntry } from '../helpers/get-installation-entry';\nimport { refreshAuthToken } from '../helpers/refresh-auth-token';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\n\nexport async function getId(\n  dependencies: FirebaseDependencies\n): Promise<string> {\n  const { installationEntry, registrationPromise } = await getInstallationEntry(\n    dependencies.appConfig\n  );\n\n  if (registrationPromise) {\n    registrationPromise.catch(console.error);\n  } else {\n    // If the installation is already registered, update the authentication\n    // token if needed.\n    refreshAuthToken(dependencies).catch(console.error);\n  }\n\n  return installationEntry.fid;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getInstallationEntry } from '../helpers/get-installation-entry';\nimport { refreshAuthToken } from '../helpers/refresh-auth-token';\nimport { AppConfig } from '../interfaces/app-config';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\n\nexport async function getToken(\n  dependencies: FirebaseDependencies,\n  forceRefresh = false\n): Promise<string> {\n  await completeInstallationRegistration(dependencies.appConfig);\n\n  // At this point we either have a Registered Installation in the DB, or we've\n  // already thrown an error.\n  const authToken = await refreshAuthToken(dependencies, forceRefresh);\n  return authToken.token;\n}\n\nasync function completeInstallationRegistration(\n  appConfig: AppConfig\n): Promise<void> {\n  const { registrationPromise } = await getInstallationEntry(appConfig);\n\n  if (registrationPromise) {\n    // A createInstallation request is in progress. Wait until it finishes.\n    await registrationPromise;\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppConfig } from '../interfaces/app-config';\nimport { RegisteredInstallationEntry } from '../interfaces/installation-entry';\nimport {\n  getErrorFromResponse,\n  getHeadersWithAuth,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\n\nexport async function deleteInstallationRequest(\n  appConfig: AppConfig,\n  installationEntry: RegisteredInstallationEntry\n): Promise<void> {\n  const endpoint = getDeleteEndpoint(appConfig, installationEntry);\n\n  const headers = getHeadersWithAuth(appConfig, installationEntry);\n  const request: RequestInit = {\n    method: 'DELETE',\n    headers\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (!response.ok) {\n    throw await getErrorFromResponse('Delete Installation', response);\n  }\n}\n\nfunction getDeleteEndpoint(\n  appConfig: AppConfig,\n  { fid }: RegisteredInstallationEntry\n): string {\n  return `${getInstallationsEndpoint(appConfig)}/${fid}`;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { deleteInstallationRequest } from '../api/delete-installation-request';\nimport { remove, update } from '../helpers/idb-manager';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\nimport { RequestStatus } from '../interfaces/installation-entry';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport async function deleteInstallation(\n  dependencies: FirebaseDependencies\n): Promise<void> {\n  const { appConfig } = dependencies;\n\n  const entry = await update(appConfig, oldEntry => {\n    if (oldEntry && oldEntry.registrationStatus === RequestStatus.NOT_STARTED) {\n      // Delete the unregistered entry without sending a deleteInstallation request.\n      return undefined;\n    }\n    return oldEntry;\n  });\n\n  if (entry) {\n    if (entry.registrationStatus === RequestStatus.IN_PROGRESS) {\n      // Can't delete while trying to register.\n      throw ERROR_FACTORY.create(ErrorCode.DELETE_PENDING_REGISTRATION);\n    } else if (entry.registrationStatus === RequestStatus.COMPLETED) {\n      if (!navigator.onLine) {\n        throw ERROR_FACTORY.create(ErrorCode.APP_OFFLINE);\n      } else {\n        await deleteInstallationRequest(appConfig, entry);\n        await remove(appConfig);\n      }\n    }\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { addCallback, removeCallback } from '../helpers/fid-changed';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\n\nexport type IdChangeCallbackFn = (installationId: string) => void;\nexport type IdChangeUnsubscribeFn = () => void;\n\n/**\n * Sets a new callback that will get called when Installation ID changes.\n * Returns an unsubscribe function that will remove the callback when called.\n */\nexport function onIdChange(\n  { appConfig }: FirebaseDependencies,\n  callback: IdChangeCallbackFn\n): IdChangeUnsubscribeFn {\n  addCallback(appConfig, callback);\n\n  return () => {\n    removeCallback(appConfig, callback);\n  };\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp, FirebaseOptions } from '@firebase/app-types';\nimport { FirebaseError } from '@firebase/util';\nimport { AppConfig } from '../interfaces/app-config';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport function extractAppConfig(app: FirebaseApp): AppConfig {\n  if (!app || !app.options) {\n    throw getMissingValueError('App Configuration');\n  }\n\n  if (!app.name) {\n    throw getMissingValueError('App Name');\n  }\n\n  // Required app config keys\n  const configKeys: Array<keyof FirebaseOptions> = [\n    'projectId',\n    'apiKey',\n    'appId'\n  ];\n\n  for (const keyName of configKeys) {\n    if (!app.options[keyName]) {\n      throw getMissingValueError(keyName);\n    }\n  }\n\n  return {\n    appName: app.name,\n    projectId: app.options.projectId!,\n    apiKey: app.options.apiKey!,\n    appId: app.options.appId!\n  };\n}\n\nfunction getMissingValueError(valueName: string): FirebaseError {\n  return ERROR_FACTORY.create(ErrorCode.MISSING_APP_CONFIG_VALUES, {\n    valueName\n  });\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport firebase from '@firebase/app';\nimport {\n  _FirebaseNamespace,\n  FirebaseService\n} from '@firebase/app-types/private';\nimport { Component, ComponentType } from '@firebase/component';\nimport { FirebaseInstallations } from '@firebase/installations-types';\nimport {\n  deleteInstallation,\n  getId,\n  getToken,\n  IdChangeCallbackFn,\n  IdChangeUnsubscribeFn,\n  onIdChange\n} from './functions';\nimport { extractAppConfig } from './helpers/extract-app-config';\nimport { FirebaseDependencies } from './interfaces/firebase-dependencies';\n\nimport { name, version } from '../package.json';\n\nexport function registerInstallations(instance: _FirebaseNamespace): void {\n  const installationsName = 'installations';\n\n  instance.INTERNAL.registerComponent(\n    new Component(\n      installationsName,\n      container => {\n        const app = container.getProvider('app').getImmediate();\n\n        // Throws if app isn't configured properly.\n        const appConfig = extractAppConfig(app);\n        const platformLoggerProvider = container.getProvider('platform-logger');\n        const dependencies: FirebaseDependencies = {\n          appConfig,\n          platformLoggerProvider\n        };\n\n        const installations: FirebaseInstallations & FirebaseService = {\n          app,\n          getId: () => getId(dependencies),\n          getToken: (forceRefresh?: boolean) =>\n            getToken(dependencies, forceRefresh),\n          delete: () => deleteInstallation(dependencies),\n          onIdChange: (callback: IdChangeCallbackFn): IdChangeUnsubscribeFn =>\n            onIdChange(dependencies, callback)\n        };\n        return installations;\n      },\n      ComponentType.PUBLIC\n    )\n  );\n\n  instance.registerVersion(name, version);\n}\n\nregisterInstallations(firebase as _FirebaseNamespace);\n\n/**\n * Define extension behavior of `registerInstallations`\n */\ndeclare module '@firebase/app-types' {\n  interface FirebaseNamespace {\n    installations(app?: FirebaseApp): FirebaseInstallations;\n  }\n  interface FirebaseApp {\n    installations(): FirebaseInstallations;\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Key to attach FID to in gtag params.\nexport const GA_FID_KEY = 'firebase_id';\nexport const ORIGIN_KEY = 'origin';\n\nexport const FETCH_TIMEOUT_MILLIS = 60 * 1000;\n\nexport const DYNAMIC_CONFIG_URL =\n  'https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig';\n\nexport const GTAG_URL = 'https://www.googletagmanager.com/gtag/js';\n\nexport enum GtagCommand {\n  EVENT = 'event',\n  SET = 'set',\n  CONFIG = 'config'\n}\n\n/**\n * Officially recommended event names for gtag.js\n * Any other string is also allowed.\n *\n * @public\n */\nexport enum EventName {\n  ADD_SHIPPING_INFO = 'add_shipping_info',\n  ADD_PAYMENT_INFO = 'add_payment_info',\n  ADD_TO_CART = 'add_to_cart',\n  ADD_TO_WISHLIST = 'add_to_wishlist',\n  BEGIN_CHECKOUT = 'begin_checkout',\n  /**\n   * @deprecated\n   * This event name is deprecated and is unsupported in updated\n   * Enhanced Ecommerce reports.\n   */\n  CHECKOUT_PROGRESS = 'checkout_progress',\n  EXCEPTION = 'exception',\n  GENERATE_LEAD = 'generate_lead',\n  LOGIN = 'login',\n  PAGE_VIEW = 'page_view',\n  PURCHASE = 'purchase',\n  REFUND = 'refund',\n  REMOVE_FROM_CART = 'remove_from_cart',\n  SCREEN_VIEW = 'screen_view',\n  SEARCH = 'search',\n  SELECT_CONTENT = 'select_content',\n  SELECT_ITEM = 'select_item',\n  SELECT_PROMOTION = 'select_promotion',\n  /** @deprecated */\n  SET_CHECKOUT_OPTION = 'set_checkout_option',\n  SHARE = 'share',\n  SIGN_UP = 'sign_up',\n  TIMING_COMPLETE = 'timing_complete',\n  VIEW_CART = 'view_cart',\n  VIEW_ITEM = 'view_item',\n  VIEW_ITEM_LIST = 'view_item_list',\n  VIEW_PROMOTION = 'view_promotion',\n  VIEW_SEARCH_RESULTS = 'view_search_results'\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AnalyticsCallOptions,\n  Gtag,\n  CustomParams,\n  ControlParams,\n  EventParams\n} from '@firebase/analytics-types';\nimport { GtagCommand } from './constants';\n/**\n * Logs an analytics event through the Firebase SDK.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n * @param eventName Google Analytics event name, choose from standard list or use a custom string.\n * @param eventParams Analytics event parameters.\n */\nexport async function logEvent(\n  gtagFunction: Gtag,\n  initializationPromise: Promise<string>,\n  eventName: string,\n  eventParams?: EventParams,\n  options?: AnalyticsCallOptions\n): Promise<void> {\n  if (options && options.global) {\n    gtagFunction(GtagCommand.EVENT, eventName, eventParams);\n    return;\n  } else {\n    const measurementId = await initializationPromise;\n    const params: EventParams | ControlParams = {\n      ...eventParams,\n      'send_to': measurementId\n    };\n    gtagFunction(GtagCommand.EVENT, eventName, params);\n  }\n}\n\n/**\n * Set screen_name parameter for this Google Analytics ID.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n * @param screenName Screen name string to set.\n */\nexport async function setCurrentScreen(\n  gtagFunction: Gtag,\n  initializationPromise: Promise<string>,\n  screenName: string | null,\n  options?: AnalyticsCallOptions\n): Promise<void> {\n  if (options && options.global) {\n    gtagFunction(GtagCommand.SET, { 'screen_name': screenName });\n    return Promise.resolve();\n  } else {\n    const measurementId = await initializationPromise;\n    gtagFunction(GtagCommand.CONFIG, measurementId, {\n      update: true,\n      'screen_name': screenName\n    });\n  }\n}\n\n/**\n * Set user_id parameter for this Google Analytics ID.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n * @param id User ID string to set\n */\nexport async function setUserId(\n  gtagFunction: Gtag,\n  initializationPromise: Promise<string>,\n  id: string | null,\n  options?: AnalyticsCallOptions\n): Promise<void> {\n  if (options && options.global) {\n    gtagFunction(GtagCommand.SET, { 'user_id': id });\n    return Promise.resolve();\n  } else {\n    const measurementId = await initializationPromise;\n    gtagFunction(GtagCommand.CONFIG, measurementId, {\n      update: true,\n      'user_id': id\n    });\n  }\n}\n\n/**\n * Set all other user properties other than user_id and screen_name.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n * @param properties Map of user properties to set\n */\nexport async function setUserProperties(\n  gtagFunction: Gtag,\n  initializationPromise: Promise<string>,\n  properties: CustomParams,\n  options?: AnalyticsCallOptions\n): Promise<void> {\n  if (options && options.global) {\n    const flatProperties: { [key: string]: unknown } = {};\n    for (const key of Object.keys(properties)) {\n      // use dot notation for merge behavior in gtag.js\n      flatProperties[`user_properties.${key}`] = properties[key];\n    }\n    gtagFunction(GtagCommand.SET, flatProperties);\n    return Promise.resolve();\n  } else {\n    const measurementId = await initializationPromise;\n    gtagFunction(GtagCommand.CONFIG, measurementId, {\n      update: true,\n      'user_properties': properties\n    });\n  }\n}\n\n/**\n * Set whether collection is enabled for this ID.\n *\n * @param enabled If true, collection is enabled for this ID.\n */\nexport async function setAnalyticsCollectionEnabled(\n  initializationPromise: Promise<string>,\n  enabled: boolean\n): Promise<void> {\n  const measurementId = await initializationPromise;\n  window[`ga-disable-${measurementId}`] = !enabled;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger } from '@firebase/logger';\n\nexport const logger = new Logger('@firebase/analytics');\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DynamicConfig,\n  DataLayer,\n  Gtag,\n  CustomParams,\n  ControlParams,\n  EventParams,\n  MinimalDynamicConfig\n} from '@firebase/analytics-types';\nimport { GtagCommand, GTAG_URL } from './constants';\nimport { logger } from './logger';\n\n/**\n * Inserts gtag script tag into the page to asynchronously download gtag.\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\n */\nexport function insertScriptTag(\n  dataLayerName: string,\n  measurementId: string\n): void {\n  const script = document.createElement('script');\n  script.src = `${GTAG_URL}?l=${dataLayerName}&id=${measurementId}`;\n  script.async = true;\n  document.head.appendChild(script);\n}\n\n/**\n * Get reference to, or create, global datalayer.\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\n */\nexport function getOrCreateDataLayer(dataLayerName: string): DataLayer {\n  // Check for existing dataLayer and create if needed.\n  let dataLayer: DataLayer = [];\n  if (Array.isArray(window[dataLayerName])) {\n    dataLayer = window[dataLayerName] as DataLayer;\n  } else {\n    window[dataLayerName] = dataLayer;\n  }\n  return dataLayer;\n}\n\n/**\n * Wrapped gtag logic when gtag is called with 'config' command.\n *\n * @param gtagCore Basic gtag function that just appends to dataLayer.\n * @param initializationPromisesMap Map of appIds to their initialization promises.\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\n * @param measurementId GA Measurement ID to set config for.\n * @param gtagParams Gtag config params to set.\n */\nasync function gtagOnConfig(\n  gtagCore: Gtag,\n  initializationPromisesMap: { [appId: string]: Promise<string> },\n  dynamicConfigPromisesList: Array<\n    Promise<DynamicConfig | MinimalDynamicConfig>\n  >,\n  measurementIdToAppId: { [measurementId: string]: string },\n  measurementId: string,\n  gtagParams?: ControlParams & EventParams & CustomParams\n): Promise<void> {\n  // If config is already fetched, we know the appId and can use it to look up what FID promise we\n  /// are waiting for, and wait only on that one.\n  const correspondingAppId = measurementIdToAppId[measurementId as string];\n  try {\n    if (correspondingAppId) {\n      await initializationPromisesMap[correspondingAppId];\n    } else {\n      // If config is not fetched yet, wait for all configs (we don't know which one we need) and\n      // find the appId (if any) corresponding to this measurementId. If there is one, wait on\n      // that appId's initialization promise. If there is none, promise resolves and gtag\n      // call goes through.\n      const dynamicConfigResults = await Promise.all(dynamicConfigPromisesList);\n      const foundConfig = dynamicConfigResults.find(\n        config => config.measurementId === measurementId\n      );\n      if (foundConfig) {\n        await initializationPromisesMap[foundConfig.appId];\n      }\n    }\n  } catch (e) {\n    logger.error(e);\n  }\n  gtagCore(GtagCommand.CONFIG, measurementId, gtagParams);\n}\n\n/**\n * Wrapped gtag logic when gtag is called with 'event' command.\n *\n * @param gtagCore Basic gtag function that just appends to dataLayer.\n * @param initializationPromisesMap Map of appIds to their initialization promises.\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\n * @param measurementId GA Measurement ID to log event to.\n * @param gtagParams Params to log with this event.\n */\nasync function gtagOnEvent(\n  gtagCore: Gtag,\n  initializationPromisesMap: { [appId: string]: Promise<string> },\n  dynamicConfigPromisesList: Array<\n    Promise<DynamicConfig | MinimalDynamicConfig>\n  >,\n  measurementId: string,\n  gtagParams?: ControlParams & EventParams & CustomParams\n): Promise<void> {\n  try {\n    let initializationPromisesToWaitFor: Array<Promise<string>> = [];\n\n    // If there's a 'send_to' param, check if any ID specified matches\n    // an initializeIds() promise we are waiting for.\n    if (gtagParams && gtagParams['send_to']) {\n      let gaSendToList: string | string[] = gtagParams['send_to'];\n      // Make it an array if is isn't, so it can be dealt with the same way.\n      if (!Array.isArray(gaSendToList)) {\n        gaSendToList = [gaSendToList];\n      }\n      // Checking 'send_to' fields requires having all measurement ID results back from\n      // the dynamic config fetch.\n      const dynamicConfigResults = await Promise.all(dynamicConfigPromisesList);\n      for (const sendToId of gaSendToList) {\n        // Any fetched dynamic measurement ID that matches this 'send_to' ID\n        const foundConfig = dynamicConfigResults.find(\n          config => config.measurementId === sendToId\n        );\n        const initializationPromise =\n          foundConfig && initializationPromisesMap[foundConfig.appId];\n        if (initializationPromise) {\n          initializationPromisesToWaitFor.push(initializationPromise);\n        } else {\n          // Found an item in 'send_to' that is not associated\n          // directly with an FID, possibly a group.  Empty this array,\n          // exit the loop early, and let it get populated below.\n          initializationPromisesToWaitFor = [];\n          break;\n        }\n      }\n    }\n\n    // This will be unpopulated if there was no 'send_to' field , or\n    // if not all entries in the 'send_to' field could be mapped to\n    // a FID. In these cases, wait on all pending initialization promises.\n    if (initializationPromisesToWaitFor.length === 0) {\n      initializationPromisesToWaitFor = Object.values(\n        initializationPromisesMap\n      );\n    }\n\n    // Run core gtag function with args after all relevant initialization\n    // promises have been resolved.\n    await Promise.all(initializationPromisesToWaitFor);\n    // Workaround for http://b/141370449 - third argument cannot be undefined.\n    gtagCore(GtagCommand.EVENT, measurementId, gtagParams || {});\n  } catch (e) {\n    logger.error(e);\n  }\n}\n\n/**\n * Wraps a standard gtag function with extra code to wait for completion of\n * relevant initialization promises before sending requests.\n *\n * @param gtagCore Basic gtag function that just appends to dataLayer.\n * @param initializationPromisesMap Map of appIds to their initialization promises.\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\n */\nfunction wrapGtag(\n  gtagCore: Gtag,\n  /**\n   * Allows wrapped gtag calls to wait on whichever intialization promises are required,\n   * depending on the contents of the gtag params' `send_to` field, if any.\n   */\n  initializationPromisesMap: { [appId: string]: Promise<string> },\n  /**\n   * Wrapped gtag calls sometimes require all dynamic config fetches to have returned\n   * before determining what initialization promises (which include FIDs) to wait for.\n   */\n  dynamicConfigPromisesList: Array<\n    Promise<DynamicConfig | MinimalDynamicConfig>\n  >,\n  /**\n   * Wrapped gtag config calls can narrow down which initialization promise (with FID)\n   * to wait for if the measurementId is already fetched, by getting the corresponding appId,\n   * which is the key for the initialization promises map.\n   */\n  measurementIdToAppId: { [measurementId: string]: string }\n): Gtag {\n  /**\n   * Wrapper around gtag that ensures FID is sent with gtag calls.\n   * @param command Gtag command type.\n   * @param idOrNameOrParams Measurement ID if command is EVENT/CONFIG, params if command is SET.\n   * @param gtagParams Params if event is EVENT/CONFIG.\n   */\n  async function gtagWrapper(\n    command: 'config' | 'set' | 'event',\n    idOrNameOrParams: string | ControlParams,\n    gtagParams?: ControlParams & EventParams & CustomParams\n  ): Promise<void> {\n    try {\n      // If event, check that relevant initialization promises have completed.\n      if (command === GtagCommand.EVENT) {\n        // If EVENT, second arg must be measurementId.\n        await gtagOnEvent(\n          gtagCore,\n          initializationPromisesMap,\n          dynamicConfigPromisesList,\n          idOrNameOrParams as string,\n          gtagParams\n        );\n      } else if (command === GtagCommand.CONFIG) {\n        // If CONFIG, second arg must be measurementId.\n        await gtagOnConfig(\n          gtagCore,\n          initializationPromisesMap,\n          dynamicConfigPromisesList,\n          measurementIdToAppId,\n          idOrNameOrParams as string,\n          gtagParams\n        );\n      } else {\n        // If SET, second arg must be params.\n        gtagCore(GtagCommand.SET, idOrNameOrParams as CustomParams);\n      }\n    } catch (e) {\n      logger.error(e);\n    }\n  }\n  return gtagWrapper;\n}\n\n/**\n * Creates global gtag function or wraps existing one if found.\n * This wrapped function attaches Firebase instance ID (FID) to gtag 'config' and\n * 'event' calls that belong to the GAID associated with this Firebase instance.\n *\n * @param initializationPromisesMap Map of appIds to their initialization promises.\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\n * @param dataLayerName Name of global GA datalayer array.\n * @param gtagFunctionName Name of global gtag function (\"gtag\" if not user-specified).\n */\nexport function wrapOrCreateGtag(\n  initializationPromisesMap: { [appId: string]: Promise<string> },\n  dynamicConfigPromisesList: Array<\n    Promise<DynamicConfig | MinimalDynamicConfig>\n  >,\n  measurementIdToAppId: { [measurementId: string]: string },\n  dataLayerName: string,\n  gtagFunctionName: string\n): {\n  gtagCore: Gtag;\n  wrappedGtag: Gtag;\n} {\n  // Create a basic core gtag function\n  let gtagCore: Gtag = function (..._args: unknown[]) {\n    // Must push IArguments object, not an array.\n    (window[dataLayerName] as DataLayer).push(arguments);\n  };\n\n  // Replace it with existing one if found\n  if (\n    window[gtagFunctionName] &&\n    typeof window[gtagFunctionName] === 'function'\n  ) {\n    // @ts-ignore\n    gtagCore = window[gtagFunctionName];\n  }\n\n  window[gtagFunctionName] = wrapGtag(\n    gtagCore,\n    initializationPromisesMap,\n    dynamicConfigPromisesList,\n    measurementIdToAppId\n  );\n\n  return {\n    gtagCore,\n    wrappedGtag: window[gtagFunctionName] as Gtag\n  };\n}\n\n/**\n * Returns first script tag in DOM matching our gtag url pattern.\n */\nexport function findGtagScriptOnPage(): HTMLScriptElement | null {\n  const scriptTags = window.document.getElementsByTagName('script');\n  for (const tag of Object.values(scriptTags)) {\n    if (tag.src && tag.src.includes(GTAG_URL)) {\n      return tag;\n    }\n  }\n  return null;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorFactory, ErrorMap } from '@firebase/util';\n\nexport const enum AnalyticsError {\n  ALREADY_EXISTS = 'already-exists',\n  ALREADY_INITIALIZED = 'already-initialized',\n  INTEROP_COMPONENT_REG_FAILED = 'interop-component-reg-failed',\n  INVALID_ANALYTICS_CONTEXT = 'invalid-analytics-context',\n  INDEXEDDB_UNAVAILABLE = 'indexeddb-unavailable',\n  FETCH_THROTTLE = 'fetch-throttle',\n  CONFIG_FETCH_FAILED = 'config-fetch-failed',\n  NO_API_KEY = 'no-api-key',\n  NO_APP_ID = 'no-app-id'\n}\n\nconst ERRORS: ErrorMap<AnalyticsError> = {\n  [AnalyticsError.ALREADY_EXISTS]:\n    'A Firebase Analytics instance with the appId {$id} ' +\n    ' already exists. ' +\n    'Only one Firebase Analytics instance can be created for each appId.',\n  [AnalyticsError.ALREADY_INITIALIZED]:\n    'Firebase Analytics has already been initialized.' +\n    'settings() must be called before initializing any Analytics instance' +\n    'or it will have no effect.',\n  [AnalyticsError.INTEROP_COMPONENT_REG_FAILED]:\n    'Firebase Analytics Interop Component failed to instantiate: {$reason}',\n  [AnalyticsError.INVALID_ANALYTICS_CONTEXT]:\n    'Firebase Analytics is not supported in this environment. ' +\n    'Wrap initialization of analytics in analytics.isSupported() ' +\n    'to prevent initialization in unsupported environments. Details: {$errorInfo}',\n  [AnalyticsError.INDEXEDDB_UNAVAILABLE]:\n    'IndexedDB unavailable or restricted in this environment. ' +\n    'Wrap initialization of analytics in analytics.isSupported() ' +\n    'to prevent initialization in unsupported environments. Details: {$errorInfo}',\n  [AnalyticsError.FETCH_THROTTLE]:\n    'The config fetch request timed out while in an exponential backoff state.' +\n    ' Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.',\n  [AnalyticsError.CONFIG_FETCH_FAILED]:\n    'Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}',\n  [AnalyticsError.NO_API_KEY]:\n    'The \"apiKey\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\n    'contain a valid API key.',\n  [AnalyticsError.NO_APP_ID]:\n    'The \"appId\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\n    'contain a valid app ID.'\n};\n\ninterface ErrorParams {\n  [AnalyticsError.ALREADY_EXISTS]: { id: string };\n  [AnalyticsError.INTEROP_COMPONENT_REG_FAILED]: { reason: Error };\n  [AnalyticsError.FETCH_THROTTLE]: { throttleEndTimeMillis: number };\n  [AnalyticsError.CONFIG_FETCH_FAILED]: {\n    httpStatus: number;\n    responseMessage: string;\n  };\n  [AnalyticsError.INVALID_ANALYTICS_CONTEXT]: { errorInfo: string };\n  [AnalyticsError.INDEXEDDB_UNAVAILABLE]: { errorInfo: string };\n}\n\nexport const ERROR_FACTORY = new ErrorFactory<AnalyticsError, ErrorParams>(\n  'analytics',\n  'Analytics',\n  ERRORS\n);\n", "/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Most logic is copied from packages/remote-config/src/client/retrying_client.ts\n */\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport {\n  DynamicConfig,\n  ThrottleMetadata,\n  MinimalDynamicConfig\n} from '@firebase/analytics-types';\nimport { FirebaseError, calculateBackoffMillis } from '@firebase/util';\nimport { AnalyticsError, ERROR_FACTORY } from './errors';\nimport { DYNAMIC_CONFIG_URL, FETCH_TIMEOUT_MILLIS } from './constants';\nimport { logger } from './logger';\n\n// App config fields needed by analytics.\nexport interface AppFields {\n  appId: string;\n  apiKey: string;\n  measurementId?: string;\n}\n\n/**\n * Backoff factor for 503 errors, which we want to be conservative about\n * to avoid overloading servers. Each retry interval will be\n * BASE_INTERVAL_MILLIS * LONG_RETRY_FACTOR ^ retryCount, so the second one\n * will be ~30 seconds (with fuzzing).\n */\nexport const LONG_RETRY_FACTOR = 30;\n\n/**\n * Base wait interval to multiplied by backoffFactor^backoffCount.\n */\nconst BASE_INTERVAL_MILLIS = 1000;\n\n/**\n * Stubbable retry data storage class.\n */\nclass RetryData {\n  constructor(\n    public throttleMetadata: { [appId: string]: ThrottleMetadata } = {},\n    public intervalMillis: number = BASE_INTERVAL_MILLIS\n  ) {}\n\n  getThrottleMetadata(appId: string): ThrottleMetadata {\n    return this.throttleMetadata[appId];\n  }\n\n  setThrottleMetadata(appId: string, metadata: ThrottleMetadata): void {\n    this.throttleMetadata[appId] = metadata;\n  }\n\n  deleteThrottleMetadata(appId: string): void {\n    delete this.throttleMetadata[appId];\n  }\n}\n\nconst defaultRetryData = new RetryData();\n\n/**\n * Set GET request headers.\n * @param apiKey App API key.\n */\nfunction getHeaders(apiKey: string): Headers {\n  return new Headers({\n    Accept: 'application/json',\n    'x-goog-api-key': apiKey\n  });\n}\n\n/**\n * Fetches dynamic config from backend.\n * @param app Firebase app to fetch config for.\n */\nexport async function fetchDynamicConfig(\n  appFields: AppFields\n): Promise<DynamicConfig> {\n  const { appId, apiKey } = appFields;\n  const request: RequestInit = {\n    method: 'GET',\n    headers: getHeaders(apiKey)\n  };\n  const appUrl = DYNAMIC_CONFIG_URL.replace('{app-id}', appId);\n  const response = await fetch(appUrl, request);\n  if (response.status !== 200 && response.status !== 304) {\n    let errorMessage = '';\n    try {\n      // Try to get any error message text from server response.\n      const jsonResponse = (await response.json()) as {\n        error?: { message?: string };\n      };\n      if (jsonResponse.error?.message) {\n        errorMessage = jsonResponse.error.message;\n      }\n    } catch (_ignored) {}\n    throw ERROR_FACTORY.create(AnalyticsError.CONFIG_FETCH_FAILED, {\n      httpStatus: response.status,\n      responseMessage: errorMessage\n    });\n  }\n  return response.json();\n}\n\n/**\n * Fetches dynamic config from backend, retrying if failed.\n * @param app Firebase app to fetch config for.\n */\nexport async function fetchDynamicConfigWithRetry(\n  app: FirebaseApp,\n  // retryData and timeoutMillis are parameterized to allow passing a different value for testing.\n  retryData: RetryData = defaultRetryData,\n  timeoutMillis?: number\n): Promise<DynamicConfig | MinimalDynamicConfig> {\n  const { appId, apiKey, measurementId } = app.options;\n\n  if (!appId) {\n    throw ERROR_FACTORY.create(AnalyticsError.NO_APP_ID);\n  }\n\n  if (!apiKey) {\n    if (measurementId) {\n      return {\n        measurementId,\n        appId\n      };\n    }\n    throw ERROR_FACTORY.create(AnalyticsError.NO_API_KEY);\n  }\n\n  const throttleMetadata: ThrottleMetadata = retryData.getThrottleMetadata(\n    appId\n  ) || {\n    backoffCount: 0,\n    throttleEndTimeMillis: Date.now()\n  };\n\n  const signal = new AnalyticsAbortSignal();\n\n  setTimeout(\n    async () => {\n      // Note a very low delay, eg < 10ms, can elapse before listeners are initialized.\n      signal.abort();\n    },\n    timeoutMillis !== undefined ? timeoutMillis : FETCH_TIMEOUT_MILLIS\n  );\n\n  return attemptFetchDynamicConfigWithRetry(\n    { appId, apiKey, measurementId },\n    throttleMetadata,\n    signal,\n    retryData\n  );\n}\n\n/**\n * Runs one retry attempt.\n * @param appFields Necessary app config fields.\n * @param throttleMetadata Ongoing metadata to determine throttling times.\n * @param signal Abort signal.\n */\nasync function attemptFetchDynamicConfigWithRetry(\n  appFields: AppFields,\n  { throttleEndTimeMillis, backoffCount }: ThrottleMetadata,\n  signal: AnalyticsAbortSignal,\n  retryData: RetryData = defaultRetryData // for testing\n): Promise<DynamicConfig | MinimalDynamicConfig> {\n  const { appId, measurementId } = appFields;\n  // Starts with a (potentially zero) timeout to support resumption from stored state.\n  // Ensures the throttle end time is honored if the last attempt timed out.\n  // Note the SDK will never make a request if the fetch timeout expires at this point.\n  try {\n    await setAbortableTimeout(signal, throttleEndTimeMillis);\n  } catch (e) {\n    if (measurementId) {\n      logger.warn(\n        `Timed out fetching this Firebase app's measurement ID from the server.` +\n          ` Falling back to the measurement ID ${measurementId}` +\n          ` provided in the \"measurementId\" field in the local Firebase config. [${e.message}]`\n      );\n      return { appId, measurementId };\n    }\n    throw e;\n  }\n\n  try {\n    const response = await fetchDynamicConfig(appFields);\n\n    // Note the SDK only clears throttle state if response is success or non-retriable.\n    retryData.deleteThrottleMetadata(appId);\n\n    return response;\n  } catch (e) {\n    if (!isRetriableError(e)) {\n      retryData.deleteThrottleMetadata(appId);\n      if (measurementId) {\n        logger.warn(\n          `Failed to fetch this Firebase app's measurement ID from the server.` +\n            ` Falling back to the measurement ID ${measurementId}` +\n            ` provided in the \"measurementId\" field in the local Firebase config. [${e.message}]`\n        );\n        return { appId, measurementId };\n      } else {\n        throw e;\n      }\n    }\n\n    const backoffMillis =\n      Number(e.customData.httpStatus) === 503\n        ? calculateBackoffMillis(\n            backoffCount,\n            retryData.intervalMillis,\n            LONG_RETRY_FACTOR\n          )\n        : calculateBackoffMillis(backoffCount, retryData.intervalMillis);\n\n    // Increments backoff state.\n    const throttleMetadata = {\n      throttleEndTimeMillis: Date.now() + backoffMillis,\n      backoffCount: backoffCount + 1\n    };\n\n    // Persists state.\n    retryData.setThrottleMetadata(appId, throttleMetadata);\n    logger.debug(`Calling attemptFetch again in ${backoffMillis} millis`);\n\n    return attemptFetchDynamicConfigWithRetry(\n      appFields,\n      throttleMetadata,\n      signal,\n      retryData\n    );\n  }\n}\n\n/**\n * Supports waiting on a backoff by:\n *\n * <ul>\n *   <li>Promisifying setTimeout, so we can set a timeout in our Promise chain</li>\n *   <li>Listening on a signal bus for abort events, just like the Fetch API</li>\n *   <li>Failing in the same way the Fetch API fails, so timing out a live request and a throttled\n *       request appear the same.</li>\n * </ul>\n *\n * <p>Visible for testing.\n */\nfunction setAbortableTimeout(\n  signal: AnalyticsAbortSignal,\n  throttleEndTimeMillis: number\n): Promise<void> {\n  return new Promise((resolve, reject) => {\n    // Derives backoff from given end time, normalizing negative numbers to zero.\n    const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);\n\n    const timeout = setTimeout(resolve, backoffMillis);\n\n    // Adds listener, rather than sets onabort, because signal is a shared object.\n    signal.addEventListener(() => {\n      clearTimeout(timeout);\n      // If the request completes before this timeout, the rejection has no effect.\n      reject(\n        ERROR_FACTORY.create(AnalyticsError.FETCH_THROTTLE, {\n          throttleEndTimeMillis\n        })\n      );\n    });\n  });\n}\n\ntype RetriableError = FirebaseError & { customData: { httpStatus: string } };\n\n/**\n * Returns true if the {@link Error} indicates a fetch request may succeed later.\n */\nfunction isRetriableError(e: Error): e is RetriableError {\n  if (!(e instanceof FirebaseError) || !e.customData) {\n    return false;\n  }\n\n  // Uses string index defined by ErrorData, which FirebaseError implements.\n  const httpStatus = Number(e.customData['httpStatus']);\n\n  return (\n    httpStatus === 429 ||\n    httpStatus === 500 ||\n    httpStatus === 503 ||\n    httpStatus === 504\n  );\n}\n\n/**\n * Shims a minimal AbortSignal (copied from Remote Config).\n *\n * <p>AbortController's AbortSignal conveniently decouples fetch timeout logic from other aspects\n * of networking, such as retries. Firebase doesn't use AbortController enough to justify a\n * polyfill recommendation, like we do with the Fetch API, but this minimal shim can easily be\n * swapped out if/when we do.\n */\nexport class AnalyticsAbortSignal {\n  listeners: Array<() => void> = [];\n  addEventListener(listener: () => void): void {\n    this.listeners.push(listener);\n  }\n  abort(): void {\n    this.listeners.forEach(listener => listener());\n  }\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DynamicConfig,\n  Gtag,\n  MinimalDynamicConfig\n} from '@firebase/analytics-types';\nimport { GtagCommand, GA_FID_KEY, ORIGIN_KEY } from './constants';\nimport { FirebaseInstallations } from '@firebase/installations-types';\nimport { fetchDynamicConfigWithRetry } from './get-config';\nimport { logger } from './logger';\nimport { FirebaseApp } from '@firebase/app-types';\nimport {\n  isIndexedDBAvailable,\n  validateIndexedDBOpenable\n} from '@firebase/util';\nimport { ERROR_FACTORY, AnalyticsError } from './errors';\nimport { findGtagScriptOnPage, insertScriptTag } from './helpers';\n\nasync function validateIndexedDB(): Promise<boolean> {\n  if (!isIndexedDBAvailable()) {\n    logger.warn(\n      ERROR_FACTORY.create(AnalyticsError.INDEXEDDB_UNAVAILABLE, {\n        errorInfo: 'IndexedDB is not available in this environment.'\n      }).message\n    );\n    return false;\n  } else {\n    try {\n      await validateIndexedDBOpenable();\n    } catch (e) {\n      logger.warn(\n        ERROR_FACTORY.create(AnalyticsError.INDEXEDDB_UNAVAILABLE, {\n          errorInfo: e\n        }).message\n      );\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Initialize the analytics instance in gtag.js by calling config command with fid.\n *\n * NOTE: We combine analytics initialization and setting fid together because we want fid to be\n * part of the `page_view` event that's sent during the initialization\n * @param app Firebase app\n * @param gtagCore The gtag function that's not wrapped.\n * @param dynamicConfigPromisesList Array of all dynamic config promises.\n * @param measurementIdToAppId Maps measurementID to appID.\n * @param installations FirebaseInstallations instance.\n *\n * @returns Measurement ID.\n */\nexport async function initializeIds(\n  app: FirebaseApp,\n  dynamicConfigPromisesList: Array<\n    Promise<DynamicConfig | MinimalDynamicConfig>\n  >,\n  measurementIdToAppId: { [key: string]: string },\n  installations: FirebaseInstallations,\n  gtagCore: Gtag,\n  dataLayerName: string\n): Promise<string> {\n  const dynamicConfigPromise = fetchDynamicConfigWithRetry(app);\n  // Once fetched, map measurementIds to appId, for ease of lookup in wrapped gtag function.\n  dynamicConfigPromise\n    .then(config => {\n      measurementIdToAppId[config.measurementId] = config.appId;\n      if (\n        app.options.measurementId &&\n        config.measurementId !== app.options.measurementId\n      ) {\n        logger.warn(\n          `The measurement ID in the local Firebase config (${app.options.measurementId})` +\n            ` does not match the measurement ID fetched from the server (${config.measurementId}).` +\n            ` To ensure analytics events are always sent to the correct Analytics property,` +\n            ` update the` +\n            ` measurement ID field in the local config or remove it from the local config.`\n        );\n      }\n    })\n    .catch(e => logger.error(e));\n  // Add to list to track state of all dynamic config promises.\n  dynamicConfigPromisesList.push(dynamicConfigPromise);\n\n  const fidPromise: Promise<string | undefined> = validateIndexedDB().then(\n    envIsValid => {\n      if (envIsValid) {\n        return installations.getId();\n      } else {\n        return undefined;\n      }\n    }\n  );\n\n  const [dynamicConfig, fid] = await Promise.all([\n    dynamicConfigPromise,\n    fidPromise\n  ]);\n\n  // Detect if user has already put the gtag <script> tag on this page.\n  if (!findGtagScriptOnPage()) {\n    insertScriptTag(dataLayerName, dynamicConfig.measurementId);\n  }\n\n  // This command initializes gtag.js and only needs to be called once for the entire web app,\n  // but since it is idempotent, we can call it multiple times.\n  // We keep it together with other initialization logic for better code structure.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  gtagCore('js' as any, new Date());\n\n  const configProperties: { [key: string]: string | boolean } = {\n    // guard against developers accidentally setting properties with prefix `firebase_`\n    [ORIGIN_KEY]: 'firebase',\n    update: true\n  };\n\n  if (fid != null) {\n    configProperties[GA_FID_KEY] = fid;\n  }\n\n  // It should be the first config command called on this GA-ID\n  // Initialize this GA-ID and set FID on it using the gtag config API.\n  // Note: This will trigger a page_view event unless 'send_page_view' is set to false in\n  // `configProperties`.\n  gtagCore(GtagCommand.CONFIG, dynamicConfig.measurementId, configProperties);\n  return dynamicConfig.measurementId;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  FirebaseAnalytics,\n  Gtag,\n  SettingsOptions,\n  DynamicConfig,\n  MinimalDynamicConfig,\n  AnalyticsCallOptions,\n  CustomParams,\n  EventParams\n} from '@firebase/analytics-types';\nimport {\n  logEvent,\n  setCurrentScreen,\n  setUserId,\n  setUserProperties,\n  setAnalyticsCollectionEnabled\n} from './functions';\nimport { getOrCreateDataLayer, wrapOrCreateGtag } from './helpers';\nimport { AnalyticsError, ERROR_FACTORY } from './errors';\nimport { FirebaseApp } from '@firebase/app-types';\nimport { FirebaseInstallations } from '@firebase/installations-types';\nimport { areCookiesEnabled, isBrowserExtension } from '@firebase/util';\nimport { initializeIds } from './initialize-ids';\nimport { logger } from './logger';\nimport { FirebaseService } from '@firebase/app-types/private';\n\ninterface FirebaseAnalyticsInternal\n  extends FirebaseAnalytics,\n    FirebaseService {}\n\n/**\n * Maps appId to full initialization promise. Wrapped gtag calls must wait on\n * all or some of these, depending on the call's `send_to` param and the status\n * of the dynamic config fetches (see below).\n */\nlet initializationPromisesMap: {\n  [appId: string]: Promise<string>; // Promise contains measurement ID string.\n} = {};\n\n/**\n * List of dynamic config fetch promises. In certain cases, wrapped gtag calls\n * wait on all these to be complete in order to determine if it can selectively\n * wait for only certain initialization (FID) promises or if it must wait for all.\n */\nlet dynamicConfigPromisesList: Array<\n  Promise<DynamicConfig | MinimalDynamicConfig>\n> = [];\n\n/**\n * Maps fetched measurementIds to appId. Populated when the app's dynamic config\n * fetch completes. If already populated, gtag config calls can use this to\n * selectively wait for only this app's initialization promise (FID) instead of all\n * initialization promises.\n */\nconst measurementIdToAppId: { [measurementId: string]: string } = {};\n\n/**\n * Name for window global data layer array used by GA: defaults to 'dataLayer'.\n */\nlet dataLayerName: string = 'dataLayer';\n\n/**\n * Name for window global gtag function used by GA: defaults to 'gtag'.\n */\nlet gtagName: string = 'gtag';\n\n/**\n * Reproduction of standard gtag function or reference to existing\n * gtag function on window object.\n */\nlet gtagCoreFunction: Gtag;\n\n/**\n * Wrapper around gtag function that ensures FID is sent with all\n * relevant event and config calls.\n */\nlet wrappedGtagFunction: Gtag;\n\n/**\n * Flag to ensure page initialization steps (creation or wrapping of\n * dataLayer and gtag script) are only run once per page load.\n */\nlet globalInitDone: boolean = false;\n\n/**\n * For testing\n */\nexport function resetGlobalVars(\n  newGlobalInitDone = false,\n  newInitializationPromisesMap = {},\n  newDynamicPromises = []\n): void {\n  globalInitDone = newGlobalInitDone;\n  initializationPromisesMap = newInitializationPromisesMap;\n  dynamicConfigPromisesList = newDynamicPromises;\n  dataLayerName = 'dataLayer';\n  gtagName = 'gtag';\n}\n\n/**\n * For testing\n */\nexport function getGlobalVars(): {\n  initializationPromisesMap: { [appId: string]: Promise<string> };\n  dynamicConfigPromisesList: Array<\n    Promise<DynamicConfig | MinimalDynamicConfig>\n  >;\n} {\n  return {\n    initializationPromisesMap,\n    dynamicConfigPromisesList\n  };\n}\n\n/**\n * This must be run before calling firebase.analytics() or it won't\n * have any effect.\n * @param options Custom gtag and dataLayer names.\n */\nexport function settings(options: SettingsOptions): void {\n  if (globalInitDone) {\n    throw ERROR_FACTORY.create(AnalyticsError.ALREADY_INITIALIZED);\n  }\n  if (options.dataLayerName) {\n    dataLayerName = options.dataLayerName;\n  }\n  if (options.gtagName) {\n    gtagName = options.gtagName;\n  }\n}\n\n/**\n * Returns true if no environment mismatch is found.\n * If environment mismatches are found, throws an INVALID_ANALYTICS_CONTEXT\n * error that also lists details for each mismatch found.\n */\nfunction warnOnBrowserContextMismatch(): void {\n  const mismatchedEnvMessages = [];\n  if (isBrowserExtension()) {\n    mismatchedEnvMessages.push('This is a browser extension environment.');\n  }\n  if (!areCookiesEnabled()) {\n    mismatchedEnvMessages.push('Cookies are not available.');\n  }\n  if (mismatchedEnvMessages.length > 0) {\n    const details = mismatchedEnvMessages\n      .map((message, index) => `(${index + 1}) ${message}`)\n      .join(' ');\n    const err = ERROR_FACTORY.create(AnalyticsError.INVALID_ANALYTICS_CONTEXT, {\n      errorInfo: details\n    });\n    logger.warn(err.message);\n  }\n}\n\nexport function factory(\n  app: FirebaseApp,\n  installations: FirebaseInstallations\n): FirebaseAnalytics {\n  warnOnBrowserContextMismatch();\n  const appId = app.options.appId;\n  if (!appId) {\n    throw ERROR_FACTORY.create(AnalyticsError.NO_APP_ID);\n  }\n  if (!app.options.apiKey) {\n    if (app.options.measurementId) {\n      logger.warn(\n        `The \"apiKey\" field is empty in the local Firebase config. This is needed to fetch the latest` +\n          ` measurement ID for this Firebase app. Falling back to the measurement ID ${app.options.measurementId}` +\n          ` provided in the \"measurementId\" field in the local Firebase config.`\n      );\n    } else {\n      throw ERROR_FACTORY.create(AnalyticsError.NO_API_KEY);\n    }\n  }\n  if (initializationPromisesMap[appId] != null) {\n    throw ERROR_FACTORY.create(AnalyticsError.ALREADY_EXISTS, {\n      id: appId\n    });\n  }\n\n  if (!globalInitDone) {\n    // Steps here should only be done once per page: creation or wrapping\n    // of dataLayer and global gtag function.\n\n    getOrCreateDataLayer(dataLayerName);\n\n    const { wrappedGtag, gtagCore } = wrapOrCreateGtag(\n      initializationPromisesMap,\n      dynamicConfigPromisesList,\n      measurementIdToAppId,\n      dataLayerName,\n      gtagName\n    );\n    wrappedGtagFunction = wrappedGtag;\n    gtagCoreFunction = gtagCore;\n\n    globalInitDone = true;\n  }\n  // Async but non-blocking.\n  // This map reflects the completion state of all promises for each appId.\n  initializationPromisesMap[appId] = initializeIds(\n    app,\n    dynamicConfigPromisesList,\n    measurementIdToAppId,\n    installations,\n    gtagCoreFunction,\n    dataLayerName\n  );\n\n  const analyticsInstance: FirebaseAnalyticsInternal = {\n    app,\n    // Public methods return void for API simplicity and to better match gtag,\n    // while internal implementations return promises.\n    logEvent: (\n      eventName: string,\n      eventParams?: EventParams | CustomParams,\n      options?: AnalyticsCallOptions\n    ) => {\n      logEvent(\n        wrappedGtagFunction,\n        initializationPromisesMap[appId],\n        eventName,\n        eventParams,\n        options\n      ).catch(e => logger.error(e));\n    },\n    setCurrentScreen: (screenName, options) => {\n      setCurrentScreen(\n        wrappedGtagFunction,\n        initializationPromisesMap[appId],\n        screenName,\n        options\n      ).catch(e => logger.error(e));\n    },\n    setUserId: (id, options) => {\n      setUserId(\n        wrappedGtagFunction,\n        initializationPromisesMap[appId],\n        id,\n        options\n      ).catch(e => logger.error(e));\n    },\n    setUserProperties: (properties, options) => {\n      setUserProperties(\n        wrappedGtagFunction,\n        initializationPromisesMap[appId],\n        properties,\n        options\n      ).catch(e => logger.error(e));\n    },\n    setAnalyticsCollectionEnabled: enabled => {\n      setAnalyticsCollectionEnabled(\n        initializationPromisesMap[appId],\n        enabled\n      ).catch(e => logger.error(e));\n    },\n    INTERNAL: {\n      delete: (): Promise<void> => {\n        delete initializationPromisesMap[appId];\n        return Promise.resolve();\n      }\n    }\n  };\n\n  return analyticsInstance;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport firebase from '@firebase/app';\nimport '@firebase/installations';\nimport { FirebaseAnalytics } from '@firebase/analytics-types';\nimport { FirebaseAnalyticsInternal } from '@firebase/analytics-interop-types';\nimport { _FirebaseNamespace } from '@firebase/app-types/private';\nimport {\n  factory,\n  settings,\n  resetGlobalVars,\n  getGlobalVars\n} from './src/factory';\nimport { EventName } from './src/constants';\nimport {\n  Component,\n  ComponentType,\n  ComponentContainer\n} from '@firebase/component';\nimport { ERROR_FACTORY, AnalyticsError } from './src/errors';\nimport {\n  isIndexedDBAvailable,\n  validateIndexedDBOpenable,\n  areCookiesEnabled,\n  isBrowserExtension\n} from '@firebase/util';\nimport { name, version } from './package.json';\n\ndeclare global {\n  interface Window {\n    [key: string]: unknown;\n  }\n}\n\n/**\n * Type constant for Firebase Analytics.\n */\nconst ANALYTICS_TYPE = 'analytics';\n\nexport function registerAnalytics(instance: _FirebaseNamespace): void {\n  instance.INTERNAL.registerComponent(\n    new Component(\n      ANALYTICS_TYPE,\n      container => {\n        // getImmediate for FirebaseApp will always succeed\n        const app = container.getProvider('app').getImmediate();\n        const installations = container\n          .getProvider('installations')\n          .getImmediate();\n\n        return factory(app, installations);\n      },\n      ComponentType.PUBLIC\n    ).setServiceProps({\n      settings,\n      EventName,\n      isSupported\n    })\n  );\n\n  instance.INTERNAL.registerComponent(\n    new Component('analytics-internal', internalFactory, ComponentType.PRIVATE)\n  );\n\n  instance.registerVersion(name, version);\n\n  function internalFactory(\n    container: ComponentContainer\n  ): FirebaseAnalyticsInternal {\n    try {\n      const analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();\n      return {\n        logEvent: analytics.logEvent\n      };\n    } catch (e) {\n      throw ERROR_FACTORY.create(AnalyticsError.INTEROP_COMPONENT_REG_FAILED, {\n        reason: e\n      });\n    }\n  }\n}\n\nexport { factory, settings, resetGlobalVars, getGlobalVars };\n\nregisterAnalytics(firebase as _FirebaseNamespace);\n\n/**\n * Define extension behavior of `registerAnalytics`\n */\ndeclare module '@firebase/app-types' {\n  interface FirebaseNamespace {\n    analytics(app?: FirebaseApp): FirebaseAnalytics;\n  }\n  interface FirebaseApp {\n    analytics(): FirebaseAnalytics;\n  }\n}\n\n/**\n * this is a public static method provided to users that wraps four different checks:\n *\n * 1. check if it's not a browser extension environment.\n * 1. check if cookie is enabled in current browser.\n * 3. check if IndexedDB is supported by the browser environment.\n * 4. check if the current browser context is valid for using IndexedDB.\n *\n */\nasync function isSupported(): Promise<boolean> {\n  if (isBrowserExtension()) {\n    return false;\n  }\n  if (!areCookiesEnabled()) {\n    return false;\n  }\n  if (!isIndexedDBAvailable()) {\n    return false;\n  }\n\n  try {\n    const isDBOpenable: boolean = await validateIndexedDBOpenable();\n    return isDBOpenable;\n  } catch (error) {\n    return false;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
